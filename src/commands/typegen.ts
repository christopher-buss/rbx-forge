import { log } from "@clack/prompts";

import ansis from "ansis";
import { mkdir, writeFile } from "node:fs/promises";
import path from "node:path";

import { name as packageName } from "../../package.json";
import { loadProjectConfig } from "../config";
import { formatDuration } from "../utils/format-duration";
import { createPathFilter } from "../utils/pattern-matcher";
import type { RojoSourceMap } from "../utils/rojo";
import { getRojoSourceMap } from "../utils/rojo";
import { createSpinner } from "../utils/run";

export const COMMAND = "typegen";
export const DESCRIPTION = "Generate types for Roblox services from Rojo sourcemap";

export const options = [
	{
		description: "Path to the Rojo project file (defaults to current directory)",
		flags: "--project <path>",
	},
	{
		description: "Output file path (overrides config)",
		flags: "-o, --output <path>",
	},
] as const;

export interface TypegenOptions {
	output?: string;
	project?: string;
}

const BANNED_SERVICES = new Set([
	// Plugins in the debugger should not be accessed directly
	"PluginDebugService",
	// StarterPlayer contents are cloned elsewhere at runtime. They should not be
	// accessed directly.
	"StarterPlayer",
]);

interface BuildContext {
	indentLevel: number;
	pathSegments: ReadonlyArray<string>;
	shouldInclude: (path: string, depth: number) => boolean;
}

export async function action(commandOptions: TypegenOptions = {}): Promise<void> {
	const config = await loadProjectConfig();
	const outputPath = commandOptions.output ?? config.typegenOutputPath;

	// Create path filter from config
	const shouldInclude = createPathFilter({
		exclude: config.typegen.exclude,
		include: config.typegen.include,
		maxDepth: config.typegen.maxDepth,
	});

	log.info(ansis.bold("â†’ Generating service types"));

	const startTime = performance.now();
	const spinner = createSpinner("Fetching Rojo sourcemap...");

	const projectPath = commandOptions.project ?? config.rojoProjectPath;
	const rojoSourceMap = await getRojoSourceMap(projectPath);

	spinner.message("Generating TypeScript interfaces...");

	const interfaces = generateInterfaces(rojoSourceMap, shouldInclude);
	const fileContents = `// This file is autogenerated by ${packageName}. Do not modify.\n\n${interfaces}\n`;

	await mkdir(path.dirname(outputPath), { recursive: true });
	await writeFile(outputPath, fileContents);

	const duration = formatDuration(startTime);
	const fileInfo = `${outputPath}, ${duration}`;
	spinner.stop(`Types generated (${ansis.dim(fileInfo)})`);
}

function buildProperties(children: ReadonlyArray<RojoSourceMap>, context: BuildContext): string {
	const seen = new Set<string>();
	const lines: Array<string> = [];
	const indent = "\t".repeat(context.indentLevel);

	for (const child of children) {
		if (seen.has(child.name)) {
			continue;
		}

		// Build child path for filtering
		const childPath = context.pathSegments.concat(child.name);
		const fullPath = childPath.join("/");
		const depth = childPath.length;

		// Check filter BEFORE adding property
		const shouldIncludeThis = context.shouldInclude(fullPath, depth);
		if (!shouldIncludeThis) {
			continue;
		}

		seen.add(child.name);
		const childContext: BuildContext = {
			...context,
			pathSegments: childPath,
		};

		lines.push(buildPropertyLine(child, indent, childContext));
	}

	return lines.join("\n");
}

function buildPropertyLine(
	sourceMap: RojoSourceMap,
	indent: string,
	context: BuildContext,
): string {
	// Workspace.Terrain is `readonly` and TypeScript will complain that all
	// declarations must have identical modifiers
	const isReadonly =
		context.pathSegments[0] === "Workspace" && context.pathSegments[1] === "Terrain";
	const modifier = isReadonly ? "readonly " : "";
	const propertyName = escapePropertyName(sourceMap.name);
	const typeStr = buildTypeString(sourceMap, context);
	return `${indent}${modifier}${propertyName}: ${typeStr};`;
}

function buildTypeString(sourceMap: RojoSourceMap, context: BuildContext): string {
	let type = sourceMap.className;

	// Build full path for filtering (e.g., "ReplicatedStorage/TS/module")
	const fullPath = context.pathSegments.join("/");
	const depth = context.pathSegments.length;

	// Check if we should include this node's children
	if (sourceMap.children !== undefined && context.shouldInclude(fullPath, depth)) {
		const childContext: BuildContext = {
			...context,
			indentLevel: context.indentLevel + 1,
		};

		const props = buildProperties(sourceMap.children, childContext);

		// Only add the intersection type if we actually have properties
		if (props.length > 0) {
			const closingIndent = "\t".repeat(context.indentLevel);
			type += ` & {\n${props}\n${closingIndent}}`;
		}
	}

	return type;
}

function escapePropertyName(name: string): string {
	const isValidIdentifier = /^[\w$]+$/.test(name) && !/^\d/.test(name);
	return isValidIdentifier ? name : `"${name}"`;
}

function generateInterfaces(
	rojoSourceMap: RojoSourceMap,
	shouldInclude: (path: string, depth: number) => boolean,
): string {
	if (rojoSourceMap.children === undefined) {
		return "";
	}

	const interfaces: Array<string> = [];

	for (const service of rojoSourceMap.children) {
		if (BANNED_SERVICES.has(service.name) || service.children === undefined) {
			continue;
		}

		const context: BuildContext = {
			indentLevel: 1,
			pathSegments: [service.name],
			shouldInclude,
		};

		const members = buildProperties(service.children, context);

		// Only generate interface if it has members
		if (members.length > 0) {
			interfaces.push(`interface ${service.name} {\n${members}\n}`);
		}
	}

	return interfaces.join("\n\n");
}
